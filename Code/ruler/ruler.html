<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Reina</title>
  <!-- TODO: Put in three.js repo REV 124 or something -->
  <!-- Currently draws a blob that covers the entire screen no matter how small I make the font. -->
  <!-- This should be using raycasting. -->
  <!-- Basically, it's crap. But it's using FontLoader. -->
  <style>
    #info {
      font-size: x-large;
      position: absolute;
      z-index: 1;
      top: 0;
      width: 100%;
      text-align: center;
      color: #ff0;
    }
  </style>
</head>
<body>
<div id="info">Run from three.js repo REV 124</div>
<script type="module">
  import * as THREE from '../build/three.module.js';

  // todo: TextGeometry, FontLoader and Font moved to examples in eb58ff1
  // But then THREE.Geometry is not a constructor :p
  // import { FontLoader } from './jsm/loaders/FontLoader.js';
  // import { TextGeometry } from './jsm/geometries/TextGeometry.js';

  import { FontLoader } from '../src/loaders/FontLoader.js';
  import { TextGeometry } from '../src/geometries/TextGeometry.js';

  console.log(`%cREVISION ${THREE.REVISION}`, "color: #ff00cc;");

  let line;
  let isDown;
  let startx = [];
  let endx = [];
  let starty = [];
  let endy = [];
  let temp = 0;
  let trigger = '1';
  let text;

  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;

  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Create a line material
  let material = new THREE.LineBasicMaterial({ color: 0x00ff00 });

  // Create an empty geometry for the line
  let geometry = new THREE.Geometry(); // todo: BufferGeometry

  // Create a group to hold the line and text
  let group = new THREE.Group();
  scene.add(group);

  // Event listener for mouse down
  function onMouseDown(event) {
    let pointer = getPointer(event);
    if (trigger === '1') {
      isDown = true;
      startx[temp] = pointer.x;
      starty[temp] = pointer.y;
      geometry.vertices.push(new THREE.Vector3(pointer.x, pointer.y, 0));
      line = new THREE.Line(geometry, material);
      group.add(line);
    } else {
      // Update object coordinates
      group.children.forEach(obj => {
        obj.geometry.verticesNeedUpdate = true;
        obj.geometry.computeBoundingSphere();
      });
    }
  }

  // Event listener for mouse move
  function onMouseMove(event) {
    if (!isDown) return;
    scene.remove(text);
    renderer.render(scene, camera);
    let pointer = getPointer(event);
    line.geometry.vertices.push({"x": pointer.x, "y": pointer.y, "z": 0});
    endx[temp] = pointer.x;
    endy[temp] = pointer.y;

    if (trigger === '1') {
      let px = Calculate.lineLength(startx[temp], starty[temp], endx[temp], endy[temp]).toFixed(2);

      let loader = new FontLoader();

      loader.load('./fonts/helvetiker_bold.typeface.json', function (font) {

        let textGeometry = new TextGeometry(`Length ${px}`, {
          size: 0.1,
          font: font
        });

        let textMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        text = new THREE.Mesh(textGeometry, textMaterial);
        text.position.set(endx[temp], endy[temp], 0);
        group.add(text);
        // scene.add(text);
      });
    }

    line.geometry.verticesNeedUpdate = true;
    renderer.render(scene, camera);
  }

  // Event listener for mouse up
  function onMouseUp(event) {
    isDown = false;
  }

  // TODO: THIS SHOULD BE USING RAYCASTING!
  function getPointer(event) {
    // Get normalized pointer coordinates
    let rect = renderer.domElement.getBoundingClientRect();
    let x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    let y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    return { x, y };
  }

  // Event listeners for mouse actions
  renderer.domElement.addEventListener('mousedown', onMouseDown, false);
  renderer.domElement.addEventListener('mousemove', onMouseMove, false);
  renderer.domElement.addEventListener('mouseup', onMouseUp, false);

  // Function to calculate line length
  let Calculate = {
    lineLength(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 * 1 - x1 * 1, 2) + Math.pow(y2 * 1 - y1 * 1, 2));
    },
  };

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
