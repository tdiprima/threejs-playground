<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raycast Line2</title>
  <style>
    body {
      /* Outer Space */
      background-color: #484848;
    }
  </style>
</head>
<body>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">{
    "imports": {
      "three": "/build/three.module.js"
    }
  }
</script>
<script type="module">
  import * as THREE from 'three';
  import { Line2 } from '/jsm/lines/Line2.js';
  import { LineGeometry } from '/jsm/lines/LineGeometry.js';
  import { LineMaterial } from '/jsm/lines/LineMaterial.js';
  import { OrbitControls } from '/jsm/controls/OrbitControls.js';

  // CREATE A SCENE
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 2;

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Define the points for the line
  const points = [
    0.5, 0.5, 0,
    -0.5, 0.5, 0,
    -0.5, -0.5, 0,
    0.5, -0.5, 0,
    0.5, 0.5, 0 // Close the loop
  ];

  // Create geometry
  const geometry = new LineGeometry();
  geometry.setPositions(points);

  // Create material with a line width greater than 1
  const material = new LineMaterial({
    color: 0xffffff,
    linewidth: 0.005, // Set the thickness here
    // resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Important!
  });
  // We didn't have "resolution" before

  // Create the line
  const line2 = new Line2(geometry, material);
  line2.computeLineDistances();  // This is necessary if you're using dashed lines

  // Add the line to the scene
  scene.add(line2);

  // Add OrbitControls for easy viewing
  const controls = new OrbitControls(camera, renderer.domElement);

  // RAYCASTING FUNCTION FOR Line2
  function raycastLine2(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;

    const inverseMatrix = new THREE.Matrix4();
    inverseMatrix.copy(matrixWorld).invert();

    const localRay = raycaster.ray.clone().applyMatrix4(inverseMatrix);

    const positions = geometry.attributes.position.array;
    const precision = raycaster.params.Line2 ? raycaster.params.Line2.precision : 1e-4;

    const vStart = new THREE.Vector3();
    const vEnd = new THREE.Vector3();
    const interSegment = new THREE.Vector3();
    const interRay = new THREE.Vector3();

    for (let i = 0; i < positions.length - 3; i += 3) {
      vStart.fromArray(positions, i);
      vEnd.fromArray(positions, i + 3);

      // Calculate the closest point on the line segment to the ray
      const distSq = localRay.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

      if (distSq < precision * precision) {
        interSegment.applyMatrix4(this.matrixWorld);

        const distance = raycaster.ray.origin.distanceTo(interSegment);
        if (distance < raycaster.near || distance > raycaster.far) continue;

        intersects.push({
          distance: distance,
          point: interSegment.clone(),
          object: this
        });
      }
    }
  }

  // Extend Line2 prototype to include the custom raycasting method
  Line2.prototype.raycast = raycastLine2;

  // USAGE
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  // Assuming you have a camera and mouse position set up

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(line2); // line2 is your Line2 object

  if (intersects.length > 0) {
    console.log('Line2 intersected at', intersects[0].point);
  }

  // Render loop
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Handle resizing
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    // material.resolution.set(window.innerWidth, window.innerHeight);
    // Same here. Don't do this.
  });
</script>
</body>
</html>
