<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>01100110 01110010 01100101 01100101</title>
  <!-- NOT RESPONDING TO MOUSE -->
  <link href="main.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- WE ALSO DIDN'T USE 4 DIVS & THERE'S 1 RENDERER -->
<script type="importmap">{
    "imports": {
      "three": "/build/three.module.js",
      "three/addons/": "/jsm/"
    }
  }
</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";
  import {OrbitControls} from "three/addons/controls/OrbitControls.js";

  // create four instances of the Scene and Camera
  const scene1 = new THREE.Scene();
  const camera1 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  // position camera to view the object
  camera1.position.set(0, 0, 2);
  camera1.name = "camera1";
  scene1.add(camera1);

  const scene2 = new THREE.Scene();
  const camera2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera2.position.set(0, 0, 2);
  camera2.name = "camera2";
  scene2.add(camera2);

  const scene3 = new THREE.Scene();
  const camera3 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera3.position.set(0, 0, 2);
  camera3.name = "camera3";
  scene3.add(camera3);

  const scene4 = new THREE.Scene();
  const camera4 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera4.position.set(0, 0, 2);
  camera4.name = "camera4";
  scene4.add(camera4);

  // Parent scene - why?
  const parentScene = new THREE.Scene();
  const parentCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  parentCamera.position.set(0, 0, 10);

  // Create instance of the WebGLRenderer
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Create a PlaneGeometry object
  const geometry = new THREE.PlaneGeometry(4, 3);

  // Load each image
  const loader = new THREE.TextureLoader();

  let mesh1, mesh2, mesh3, mesh4;

  const image1 = loader.load('image1.jpg', texture1 => {
    let material1 = new THREE.MeshBasicMaterial({ map: texture1, side: THREE.DoubleSide });
    // Set the position and scale of the mesh so that it fits within the canvas for that image.
    mesh1 = new THREE.Mesh(geometry, material1);
    mesh1.position.set(-2, 2, 0);
    mesh1.scale.set(1.0, texture1.image.height / texture1.image.width, 1.0);
    scene1.add(mesh1);
  });

  const image2 = loader.load('image2.jpg', texture2 => {
    let material2 = new THREE.MeshBasicMaterial({ map: texture2, side: THREE.DoubleSide });
    mesh2 = new THREE.Mesh(geometry, material2);
    mesh2.scale.set(1.0, texture2.image.height / texture2.image.width, 1.0);
    mesh2.position.set(2, 2, 0);
    scene2.add(mesh2);
  });

  const image3 = loader.load('image3.jpg', texture3 => {
    let material3 = new THREE.MeshBasicMaterial({ map: texture3, side: THREE.DoubleSide });
    mesh3 = new THREE.Mesh(geometry, material3);
    mesh3.scale.set(1.0, texture3.image.height / texture3.image.width, 1.0);
    mesh3.position.set(-2, -2, 0);
    scene3.add(mesh3);
  });

  const image4 = loader.load('image4.jpg', texture4 => {
    let material4 = new THREE.MeshBasicMaterial({ map: texture4, side: THREE.DoubleSide });
    mesh4 = new THREE.Mesh(geometry, material4);
    mesh4.scale.set(1.0, texture4.image.height / texture4.image.width, 1.0);
    mesh4.position.set(2, -2, 0);
    scene4.add(mesh4);
  });

  // Add the scenes to parent scene (this probably shouldn't be)
  parentScene.add(scene1, scene2, scene3, scene4);

  // Create the four controls
  const controls1 = new OrbitControls(camera1, renderer.domElement);
  const controls2 = new OrbitControls(camera2, renderer.domElement);
  const controls3 = new OrbitControls(camera3, renderer.domElement);
  const controls4 = new OrbitControls(camera4, renderer.domElement);
  // todo: target; see esqueletos/uno.js

  function onDocumentMouseDown(event) {
    event.preventDefault();

    const mouse = new THREE.Vector2(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, parentCamera);

    // const intersects = raycaster.intersectObjects([image1, image2, image3, image4]); // object.layers is undefined
    const intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3, mesh4]);

    if (intersects.length > 0) {
      // selectedCamera = intersects[0].object.parent.getObjectByName('camera');
      selectedCamera = intersects[0].object.parent.children[0];
      console.log("selectedCamera:", selectedCamera);
    }
  }

  // Set up event listeners to control the cameras
  let selectedCamera = null;

  // All of these fire, no matter what was clicked.
  controls1.addEventListener('start', () => { selectedCamera = camera1; });
  controls2.addEventListener('start', () => { selectedCamera = camera2; });
  controls3.addEventListener('start', () => { selectedCamera = camera3; });
  controls4.addEventListener('start', () => { selectedCamera = camera4; });

  function onDocumentMouseUp() { selectedCamera = null; }

  function onDocumentMouseMove(event) {
    event.preventDefault();

    if (selectedCamera) {
      // Retrieve the movement distance of the mouse in the horizontal (X) and vertical (Y) directions
      const deltaX = event.movementX;
      const deltaY = event.movementY;

      // Calculate the rotation angles based on the mouse movement and the window size
      const theta = (deltaX / window.innerWidth) * Math.PI * 2;
      const phi = (deltaY / window.innerHeight) * Math.PI * 2;
      // console.log(deltaX, deltaY, theta, phi);

      // Rotate the selected camera around the world Y-axis (0, 1, 0) by the horizontal angle (theta)
      selectedCamera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), theta);

      // Rotate the selected camera around the world X-axis (1, 0, 0) by the vertical angle (phi)
      selectedCamera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), phi);
    }
  }

  // Set up a function to handle window resizing
  function onWindowResize() {
    parentCamera.aspect = window.innerWidth / window.innerHeight;
    parentCamera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // add event listeners
  document.addEventListener('mousedown', onDocumentMouseDown);
  document.addEventListener('mouseup', onDocumentMouseUp);
  document.addEventListener('mousemove', onDocumentMouseMove);
  window.addEventListener('resize', onWindowResize);

  // call the render function in a loop to update the scene(s)
  function animate() {
    requestAnimationFrame(animate);

    // Update the controls
    controls1.update();
    controls2.update();
    controls3.update();
    controls4.update();

    // Render the parent scene
    renderer.render(parentScene, parentCamera);
  }

  animate();
</script>
</body>
</html>
