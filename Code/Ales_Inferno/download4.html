<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>download image portion</title>
  <link href="/css/main.css" rel="stylesheet" type="text/css">
  <script src="/build/three.min.js"></script>
</head>
<body>
<button id="download">Download</button>
<script>
  let imgSrc = "image4.jpg";

  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 2;

  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Helper function to download an image
  function download(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    link.click();
  }

  let planeGeom = new THREE.PlaneGeometry(4, 4);
  let tex = new THREE.TextureLoader().load(imgSrc, (tex) => {
    tex.needsUpdate = true;

    const width = tex.image.width;
    const height = tex.image.height;
    const aspect = height / width;
    console.log("size:", width, height);

    let planeMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      map: tex
    });

    let plane = new THREE.Mesh(planeGeom, planeMaterial);
    plane.scale.set(1.0, aspect, 1.0);
    scene.add(plane);

    document.getElementById("download").addEventListener("click", function () {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;

      // Draw the portion of the image inside the rectangle
      context.drawImage(tex.image, 0, 0, width, height);

      // Get the vertices of the rectangle in canvas coordinates
      const rectVertices = rectangle.geometry.attributes.position.array;
      const rectCanvasVertices = rectVertices.map((coord, index) => {
        if (index % 3 === 0) {
          return (coord + 1) * (width / 2);
        } else if (index % 3 === 1) {
          return (1 - coord) * (height / 2);
        }
        return coord;
      });

      // Get the minimum and maximum coordinates of the rectangle
      const minX = Math.min(...rectCanvasVertices.filter((_, i) => i % 2 === 0));
      const minY = Math.min(...rectCanvasVertices.filter((_, i) => i % 2 === 1));
      const maxX = Math.max(...rectCanvasVertices.filter((_, i) => i % 2 === 0));
      const maxY = Math.max(...rectCanvasVertices.filter((_, i) => i % 2 === 1));

      // Extract the portion of the image inside the rectangle
      const imageData = context.getImageData(minX, minY, maxX - minX, maxY - minY);

      // Create a new canvas for the extracted portion
      const extractedCanvas = document.createElement('canvas');
      const extractedContext = extractedCanvas.getContext('2d');
      extractedCanvas.width = maxX - minX;
      extractedCanvas.height = maxY - minY;

      // Draw the extracted portion on the new canvas
      extractedContext.putImageData(imageData, 0, 0);

      // Download the extracted portion as a PNG file
      const dataUrl = extractedCanvas.toDataURL('image/png');
      download(dataUrl, 'extracted.png');
    });
  });

  // CREATE THE GEOMETRY FOR A RECTANGLE
  let vertices = new Float32Array([
    -1.0, -1.0, 0.0,  // Vertex 1: bottom left
    1.0, -1.0, 0.0,   // Vertex 2: bottom right
    1.0,  1.0, 0.0,   // Vertex 3: top right
    -1.0,  1.0, 0.0   // Vertex 4: top left
  ]);

  let geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

  // Use LineLoop to draw the rectangle
  let material = new THREE.LineBasicMaterial({ color: 0x0000ff });
  let rectangle = new THREE.LineLoop(geometry, material);
  rectangle.renderOrder = 1;

  // Add the rectangle to the scene
  scene.add(rectangle);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  (function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  })();
</script>
</body>
</html>
