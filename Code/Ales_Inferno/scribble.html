<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Scribble (without Raycaster)</title>
  <!-- https://stackoverflow.com/questions/73705786/how-to-free-draw-a-line-in-three-js-r144-on-mouse-move-and-using-buffergeometry#73713583 -->
  <link href="/css/main.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Montserrat-SemiBold', 'Montserrat', 'Open Sans', 'Helvetica', 'Arial', 'sans-serif';
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="info">Draw!</div>

<script src="/build/three.min.js"></script>
<script>
  // Global variables
  let scene;
  let width;
  let height;
  let camera;
  let renderer;
  let mouseIsPressed;
  let mouseX;
  let mouseY;

  let material; // A line material
  let selected; // Object that was picked

  function setup() {
    material = new THREE.LineBasicMaterial({ color: 0xffffff, depthWrite: false, linewidth: 4 });
  }

  function mousePressed() {
    const point = new THREE.Vector3(mouseX, mouseY, 0);
    const geometry = new THREE.BufferGeometry().setFromPoints([point]);

    const line = new THREE.Line(geometry, material);
    scene.add(line);
    selected = line;
  }

  function mouseDragged() {
    const line = selected;
    const point = new THREE.Vector3(mouseX, mouseY, 0);

    const oldGeometry = line.geometry;
    const oldPositionArray = oldGeometry.attributes.position.array;
    const numVertices = oldPositionArray.length / 3;

    // Create a new array with the updated vertices
    const newPositionArray = new Float32Array(numVertices * 3 + 3);
    newPositionArray.set(oldPositionArray);

    newPositionArray[numVertices * 3] = point.x;
    newPositionArray[numVertices * 3 + 1] = point.y;
    newPositionArray[numVertices * 3 + 2] = point.z;

    // Assign new array back to the position attribute of the geometry
    const newGeometry = new THREE.BufferGeometry();
    newGeometry.setAttribute('position', new THREE.BufferAttribute(newPositionArray, 3));

    // Set needsUpdate to true for the position attribute
    newGeometry.attributes.position.needsUpdate = true;

    line.geometry = newGeometry;
  }

  function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
  }

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;

    camera.right = width;
    camera.bottom = height;

    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
    render();
  }

  window.addEventListener('resize', resize);

  // *** THE MAIN EVENT ***
  function init() {
    scene = new THREE.Scene();

    width = window.innerWidth;
    height = window.innerHeight;

    camera = new THREE.OrthographicCamera(0, width, 0, height, -height, height);
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.sortObjects = false;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);

    document.body.appendChild(renderer.domElement);

    // Set up mouse callbacks.
    mouseIsPressed = false;
    mouseX = 0;
    mouseY = 0;

    function setMouse(event) {
      mouseX = event.clientX;
      mouseY = event.clientY;
    }

    renderer.domElement.addEventListener('pointerdown', event => {
      setMouse(event);
      mouseIsPressed = true;
      if (typeof mousePressed !== 'undefined') {
        mousePressed();
      }
    });

    renderer.domElement.addEventListener('pointermove', event => {
      setMouse(event);

      if (mouseIsPressed) {
        if (typeof mouseDragged !== 'undefined') {
          mouseDragged();
        }
      }
    });

    renderer.domElement.addEventListener('pointerup', () => {
      mouseIsPressed = false;
    });

    // If a setup function is defined, call it
    if (typeof setup !== 'undefined') {
      setup();
    }

    render();
  }

  init();
</script>
</body>
</html>
