<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Free-Drawing</title>
  <link href="/css/main.css" rel="stylesheet">
</head>
<body>
  <script src="/build/three.min.js"></script>
  <script>
    console.log(`%cREVISION: ${THREE.REVISION}`, "color: #ccff00;");
    let isDrawing = false;
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x101010);
    document.body.appendChild(renderer.domElement);

    // create a plane geometry with a texture
    let geometry = new THREE.PlaneGeometry(10, 10);
    let textureLoader = new THREE.TextureLoader();

    // load the texture
    textureLoader.load('/images/uv_grid_opengl.jpg', function (texture) {
      // create a plane geometry with a texture
      let geometry = new THREE.PlaneGeometry(10, 10);
      let material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
      let mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // create a canvas element and add it as a texture to the plane geometry
      let canvas = document.createElement('canvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let context = canvas.getContext('2d');
      context.strokeStyle = "#ff0000";
      context.lineWidth = 2;

      let canvasTexture = new THREE.CanvasTexture(canvas);
      material.map = canvasTexture;

      // let element = canvas;
      let element = document;

      // allow the user to draw on the canvas
      function onCanvasMouseDown(event) {
        isDrawing = true;
        let x = event.clientX - canvas.offsetLeft;
        let y = event.clientY - canvas.offsetTop;
        context.beginPath();
        context.moveTo(x, y);
      }
      element.addEventListener('mousedown', onCanvasMouseDown);

      function onCanvasMouseMove(event) {
        if (isDrawing) {
          let x = event.clientX - canvas.offsetLeft;
          let y = event.clientY - canvas.offsetTop;
          context.lineTo(x, y);
          context.stroke();
          canvasTexture.needsUpdate = true;
        }
      }
      element.addEventListener('mousemove', onCanvasMouseMove);

      element.addEventListener('mouseup', function () {
        isDrawing = false;
        context.closePath();
        context.stroke();
      });
    });

    /* Resize Event */
    window.addEventListener("resize", function () {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    });

    /* Animate */
    (function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
