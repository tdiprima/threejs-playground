<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Two Images with Three.js</title>
  <!-- ADDED EVENT LISTENERS TO THE CONTROLS. IT WORKS. Now give option to detach. -->
  <style>
    body {
      margin: 0;
      background-color: #171717; /* woodsmoke */
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
<table>
  <tr>
    <td><div id="image1"></div></td>
    <td><div id="image2"></div></td>
  </tr>
</table>
<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}
</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="module">
  import * as THREE from "three";
  import {OrbitControls} from "three/addons/controls/OrbitControls.js";

  let RENDER_WIDTH = window.innerWidth / 2;
  let RENDER_HEIGHT = window.innerHeight / 2;
  let ASPECT = RENDER_WIDTH / RENDER_HEIGHT;

  const numScenes = 2;
  const geometry = new THREE.PlaneGeometry(1, 1);
  const loader = new THREE.TextureLoader();

  let scenes = [];
  let cameras = [];
  let renderers = [];
  let controls = [];
  let colors = ["#2b2b2b", "#484848"]; // mineShaft, outerSpace

  for (let i = 0; i < numScenes; i++) {
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(colors[i]);
    scenes.push(scene);

    let camera = new THREE.PerspectiveCamera(75, ASPECT, 0.1, 1000);
    camera.position.z = 2;
    cameras.push(camera);

    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(RENDER_WIDTH, RENDER_HEIGHT);
    document.getElementById(`image${i + 1}`).appendChild(renderer.domElement);
    renderers.push(renderer);

    let texture = new THREE.TextureLoader().load(`image${i + 1}.jpg`);
    let material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});
    let geometry = new THREE.PlaneGeometry(3, 2);
    let mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Create the OrbitControls instances for each scene
    let control = new OrbitControls(camera, renderer.domElement);
    if (i === 0) {
      control.addEventListener("change", onControlsChange1);
    } else {
      control.addEventListener("change", onControlsChange2);
    }
    controls.push(control);
  }

  // Event handler for changes in controls1
  function onControlsChange1() {
    // console.log("onControlsChange1");
    cameras[1].copy(cameras[0]);
    cameras[1].updateProjectionMatrix();
  }

  // Event handler for changes in controls2
  function onControlsChange2() {
    // console.log("onControlsChange2");
    cameras[0].copy(cameras[1]);
    cameras[0].updateProjectionMatrix();
  }

  // Update function for rendering the scenes
  function update() {
    for (let i = 0; i < numScenes; i++) {
      controls[i].update();
      renderers[i].render(scenes[i], cameras[i]);
    }
    requestAnimationFrame(update);
  }

  // Start the rendering loop
  update();
</script>
</body>
</html>
