<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Two Images with Three.js</title>
  <style>
    body {
      margin: 0;
      background-color: #171717; /* woodsmoke */
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
<button id="toggleButton">toggleButton</button>
<table>
  <tr>
    <td>
      <div id="image1"></div>
    </td>
    <td>
      <div id="image2"></div>
    </td>
  </tr>
</table>
<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/examples/": "/jsm/"
  }
}

</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="module">
  import * as THREE from "three";
  import {OrbitControls} from "three/examples/controls/OrbitControls.js";

  let RENDER_WIDTH = window.innerWidth / 2;
  let RENDER_HEIGHT = window.innerHeight / 2;
  let ASPECT = RENDER_WIDTH / RENDER_HEIGHT;

  const numScenes = 2;
  const geometry = new THREE.PlaneGeometry(1, 1);
  const loader = new THREE.TextureLoader();

  let scenes = [];
  let cameras = [];
  let renderers = [];
  let controls = [];
  let colors = ["#2b2b2b", "#484848"];

  let activeControlIndex = 0; // Index of the currently active control
  let detachControls = false; // Flag to toggle controls detachment

  for (let i = 0; i < numScenes; i++) {
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(colors[i]);
    scenes.push(scene);

    let camera = new THREE.PerspectiveCamera(75, ASPECT, 0.1, 1000);
    camera.position.z = 2;
    cameras.push(camera);

    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(RENDER_WIDTH, RENDER_HEIGHT);
    document.getElementById(`image${i + 1}`).appendChild(renderer.domElement);
    renderers.push(renderer);

    let texture = new THREE.TextureLoader().load(`image${i + 1}.jpg`);
    let material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});
    let geometry = new THREE.PlaneGeometry(3, 2);
    let mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    let control = new OrbitControls(camera, renderer.domElement);
    control.addEventListener("change", onControlsChange);
    // if (i === 0) {
    //   control.addEventListener("change", onControlsChange1);
    // } else {
    //   control.addEventListener("change", onControlsChange2);
    // }
    controls.push(control);
  }

  function onControlsChange() {
    if (detachControls) {
      cameras[1 - activeControlIndex].copy(cameras[activeControlIndex]);
      cameras[1 - activeControlIndex].updateProjectionMatrix();
    }
  }

  // function onControlsChange1() {
  //   if (detachControls) return;
  //   cameras[1].copy(cameras[0]);
  //   cameras[1].updateProjectionMatrix();
  // }

  // function onControlsChange2() {
  // if (detachControls) return;
  //   cameras[0].copy(cameras[1]);
  //   cameras[0].updateProjectionMatrix();
  // }

  function update() {
    // for (let i = 0; i < numScenes; i++) {
    //   controls[i].update();
    //   renderers[i].render(scenes[i], cameras[i]);
    // }
    controls.forEach((control, index) => {
      if (index !== activeControlIndex || !detachControls) {
        control.update();
      }
      renderers[index].render(scenes[index], cameras[index]);
    });
    requestAnimationFrame(update);
  }

  // Function to detach or reattach controls based on the 'detachControls' flag
  function toggleControlsDetachment() {
    detachControls = !detachControls;
    if (detachControls) {
      // controls[0].enabled = false;
      // controls[1].enabled = false;
      controls.forEach((control, index) => {
        control.enabled = (index === activeControlIndex);
      });
    } else {
      // controls[0].enabled = true;
      // controls[1].enabled = true;
      controls.forEach((control) => {
        control.enabled = true;
      });
    }
  }

  // Function to switch the active control
  function switchActiveControl(index) {
    activeControlIndex = index;
    controls.forEach((control, i) => {
      control.enabled = (i === activeControlIndex) || !detachControls;
    });
  }

  // Toggle button click event listener
  document.getElementById("toggleButton").addEventListener("click", toggleControlsDetachment);

  // Control switch button click event listeners
  document.getElementById("control1Button").addEventListener("click", () => {
    switchActiveControl(0);
  });

  document.getElementById("control2Button").addEventListener("click", () => {
    switchActiveControl(1);
  });

  update();
</script>
</body>
</html>
