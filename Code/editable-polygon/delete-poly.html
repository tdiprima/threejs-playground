<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Delete</title>
  <link href="/css/main.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" rel="stylesheet">
</head>
<body>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js"
  }
}
</script>
<script type="module">
  import * as THREE from "three";
  import { CSS2DRenderer, CSS2DObject } from '/jsm/renderers/CSS2DRenderer.js';

  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;

  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  let labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
  // labelRenderer.domElement.style.position = 'absolute';
  // labelRenderer.domElement.style.top = '0px';
  document.body.appendChild(labelRenderer.domElement);

  // Create an ellipse
  let ellipse;
  let material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  let segments = 64; // Number of line segments used to approximate the ellipse
  let geometry = new THREE.BufferGeometry();
  let vertices = new Float32Array((segments + 1) * 3); // (segments + 1) vertices * 3 coordinates (x, y, z)
  geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
  ellipse = new THREE.LineLoop(geometry, material);
  scene.add(ellipse);

  let objectCSS;

  // CREATE ICON HERE.
  function addIconAtPosition(position) {
    const el = document.createElement('div');
    el.innerHTML = '<i class="fa fa-trash"></i>';
    objectCSS = new CSS2DObject(el);
    objectCSS.position.set(position.x, position.y + 1, position.z);
    // objectCSS.position.set(0, 0, 0);
    scene.add(objectCSS);

    el.addEventListener('click', onIconClick, false);
  }

  function onIconClick(event) {
    console.log("onIconClick");
  }

  // function onIconClick(event) {
  //   let mouse = new THREE.Vector2();
  //   mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  //   mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  //   let raycaster = new THREE.Raycaster();
  //   raycaster.setFromCamera(mouse, camera);

  //   let intersects = raycaster.intersectObject(iconMesh);
  //   if (intersects.length > 0) {
  //     // Icon clicked, remove ellipse and icon
  //     scene.remove(ellipse);
  //     scene.remove(iconMesh);
  //   }
  // }

  // Handle mouse events
  let isDrawing = false;
  let startPoint;
  let endPoint;
  renderer.domElement.addEventListener("mousedown", onMouseDown, false);
  renderer.domElement.addEventListener("mousemove", onMouseMove, false);
  renderer.domElement.addEventListener("mouseup", onMouseUp, false);

  function onMouseDown(event) {
    event.preventDefault();
    isDrawing = true;
    startPoint = getMousePosition(event.clientX, event.clientY);
  }

  function onMouseMove(event) {
    event.preventDefault();
    if (isDrawing) {
      endPoint = getMousePosition(event.clientX, event.clientY);
      updateEllipse();
    }
  }

  function onMouseUp(event) {
    event.preventDefault();
    isDrawing = false;
    endPoint = getMousePosition(event.clientX, event.clientY);
    updateEllipse();

    // Add the delete icon
    addIconAtPosition(endPoint);
  }

  function getMousePosition(clientX, clientY) {
    let rect = renderer.domElement.getBoundingClientRect();

    let mouse = new THREE.Vector2();
    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

    let raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    let intersectionPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 0, 1)), intersectionPoint);

    return intersectionPoint;
  }

  function updateEllipse() {
    let positions = ellipse.geometry.attributes.position.array;
    let center = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    let radiusX = Math.abs(startPoint.x - endPoint.x) * 0.5;
    let radiusY = Math.abs(startPoint.y - endPoint.y) * 0.5;

    for (let i = 0; i <= segments; i++) {
      let theta = (i / segments) * Math.PI * 2;
      let x = center.x + Math.cos(theta) * radiusX;
      let y = center.y + Math.sin(theta) * radiusY;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = 0;
    }

    ellipse.geometry.attributes.position.needsUpdate = true;
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
