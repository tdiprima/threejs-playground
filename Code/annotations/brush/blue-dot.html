<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>transparent blue dot</title>
  <link href="/css/main.css" rel="stylesheet" type="text/css">
  <script src="/build/three.min.js"></script>
</head>
<body>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 2;

  let renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  let planeGeom = new THREE.PlaneGeometry(4, 4);
  let planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
  let plane = new THREE.Mesh(planeGeom, planeMaterial);
  scene.add(plane);

  let circleData = []; // Array to store each circle's center and radius
  let drawing = false; // Flag to check if drawing is active
  let brushSize = 0.1; // Size of the brush
  let brushShapeGroup = new THREE.Group(); // Group to hold brush shapes
  let raycaster = new THREE.Raycaster();

  // Function to convert mouse coordinates to Three.js coordinates using raycasting
  function getMousePos(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    const mouse = new THREE.Vector2(mouseX, mouseY);
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children);

    for (let i = 0; i < intersects.length; i++) {
      if (intersects[i].object instanceof THREE.Mesh) {
        return intersects[i].point;
      }
    }
    return null;
  }

  function startDrawing(event) {
    drawing = true;
    circleData = []; // Reset circle data for a new drawing
    brushShapeGroup = new THREE.Group();
    scene.add(brushShapeGroup);
  }

  // Function to draw the brush shape
  function drawBrush(event) {
    if (!drawing) return;
    const point = getMousePos(event);
    if (point === null) return;

    // Create a small circle at the intersection point
    const brushGeometry = new THREE.CircleGeometry(brushSize, 32);
    const brushMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.1 });
    const brushCircle = new THREE.Mesh(brushGeometry, brushMaterial);

    brushCircle.position.set(point.x, point.y, point.z);

    brushShapeGroup.add(brushCircle); // Add the circle to the group

    // Store the circle's center and radius in circleData
    circleData.push({ center: { x: point.x, y: point.y, z: point.z }, radius: brushSize });
  }

  // Function to stop drawing
  // Modify the stopDrawing function to trigger merging and rendering
  function stopDrawing() {
    drawing = false;
    // Assume `circleData` is stored while drawing
    renderMergedShape(circleData); // Pass the stored circle positions and sizes
  }

  function stopDrawing() {
    drawing = false;
    // Here, you could use circleData for further processing, like merging circles
    renderMergedShape(circleData); // This function would handle the merging and rendering based on circleData
  }

  // Assuming you have a function to calculate the merged outline from circle positions and sizes
  function calculateMergedOutline(circles) {
    // Step 1: Convert circles to polygons
    let polygons = circles.map(circle => approximateCircleAsPolygon(circle.center, circle.radius));

    // Step 2: Calculate the union of polygons
    let unionPolygon = calculateUnionOfPolygons(polygons);

    // Step 3: Simplify the resulting shape (optional)
    let simplifiedPolygon = simplifyPolygon(unionPolygon);

    // Convert the polygon back into a format suitable for Three.js (e.g., an array of Vector2)
    return polygonToVector2Array(simplifiedPolygon);
  }

  function approximateCircleAsPolygon(center, radius) {
    const points = [];
    const segmentCount = 32; // Increase for a smoother circle
    for (let i = 0; i < segmentCount; i++) {
      const theta = (i / segmentCount) * Math.PI * 2;
      const x = center.x + radius * Math.cos(theta);
      const y = center.y + radius * Math.sin(theta);
      points.push({ x, y });
    }
    return points;
  }

  function calculateUnionOfPolygons(polygons) {
    // Placeholder for union calculation
    // This would be where you integrate a computational geometry algorithm or library
    // For example, using a library like Clipper.js or a similar geometry processing library
  }

  function simplifyPolygon(polygon) {
    // Placeholder for optional polygon simplification
    // This could involve removing points that do not significantly alter the shape's visual appearance
  }

  function polygonToVector2Array(polygon) {
    // Convert polygon points to Three.js Vector2 objects for use in THREE.Shape()
    return polygon.map(point => new THREE.Vector2(point.x, point.y));
  }

  // Function to create and render the merged shape with a transparent fill
  function renderMergedShape(circleData) {
    const outlinePoints = calculateMergedOutline(circleData);
    const shape = new THREE.Shape(outlinePoints);

    const geometry = new THREE.ShapeGeometry(shape);
    const material = new THREE.MeshBasicMaterial({
      color: 0x0000ff, // Blue color
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const mergedShape = new THREE.Mesh(geometry, material);

    // Remove previous merged shape if exists and add the new one
    const existingShape = scene.getObjectByName('mergedShape');
    if (existingShape) {
      scene.remove(existingShape);
    }
    mergedShape.name = 'mergedShape';
    scene.add(mergedShape);
  }

  // Add event listeners for mouse events
  renderer.domElement.addEventListener('mousedown', startDrawing);
  renderer.domElement.addEventListener('mousemove', drawBrush);
  window.addEventListener('mouseup', stopDrawing);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  (function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  })();
</script>
</body>
</html>
